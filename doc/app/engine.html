<!DOCTYPE html><html lang="en"><head><title>app/engine</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="app/engine"><meta name="groc-project-path" content="app/engine.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">app/engine.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="quiz-running-engine">Quiz-running engine</h1></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="s1">&#39;use strict&#39;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">Quiz</span>      <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./models/quiz&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">Answer</span>    <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./models/answer&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">redis</span>     <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;redis&#39;</span><span class="p">).</span><span class="nx">createClient</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">_</span>         <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;underscore&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">events</span>    <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">async</span>     <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;async&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">colors</span>    <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;colors&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">moment</span>    <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;moment&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">Promise</span>   <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;promise&#39;</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="persistence-keys-in-the-redis-store">Persistence keys in the Redis store</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="kd">var</span> <span class="nx">AUTH_PERSIST_KEY</span>  <span class="o">=</span> <span class="s1">&#39;node-demo:ips-to-users&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">CUR_QUESTION_KEY</span>  <span class="o">=</span> <span class="s1">&#39;node-demo:current-question&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">PLAYERS_KEY</span>       <span class="o">=</span> <span class="s1">&#39;node-demo:players&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">SCOREBOARD_KEY</span>    <span class="o">=</span> <span class="s1">&#39;node-demo:score-board&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">USER_LIST_KEY</span>     <span class="o">=</span> <span class="s1">&#39;node-demo:users&#39;</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="the-engine-singleton">The Engine singleton</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This contains all the business logic for running the quiz; other parts
of the app (admin pages and player-facing pages) end up calling its
methods, and it emits events for various stages of the game.</p></div></div><div class="code"><div class="wrapper"><span class="kd">var</span> <span class="nx">Engine</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="k">new</span> <span class="nx">events</span><span class="p">.</span><span class="nx">EventEmitter</span><span class="p">(),</span> <span class="p">{</span>
  <span class="nx">currentQuiz</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">currentQuestion</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">currentQuestionExpiresAt</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nx">currentQuestionTimer</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">playerCount</span><span class="o">:</span> <span class="s1">&#39;Aucun joueur&#39;</span><span class="p">,</span>
  <span class="nx">startedAt</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="authentication-middleware-helper">Authentication middleware helper</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is called by the front pages to try and get the currently-logged
user back from the request's session or, failing that, from the
Redis-backed IP-to-player mapping, so we don't have to re-auth with
Twitter between two server starts.  This is especially useful during
dev, when the server auto-restarts at every code change.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">checkAuth</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handleUser</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">redis</span><span class="p">.</span><span class="nx">hget</span><span class="p">(</span><span class="nx">AUTH_PERSIST_KEY</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ip</span><span class="p">,</span> <span class="nx">handleRedisUser</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">handleUser</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">json</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">user</span><span class="p">),</span> <span class="nx">origScore</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Notice the use of <a href="https://github.com/caolan/async#waterfall"><code>async.waterfall</code></a>
here.  We make heavy use of that trick to chain multiple traditional (non-promise)
async call whose results feed into each other (at least for some of the calls).
This is one way of avoiding the “Pyramid of Doom” effect.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">async</span><span class="p">.</span><span class="nx">waterfall</span><span class="p">([</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>1: persist the current user in the IP-to-player map</p></div></div><div class="code"><div class="wrapper">        <span class="kd">function</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span>        <span class="p">{</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">hset</span><span class="p">(</span><span class="nx">AUTH_PERSIST_KEY</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ip</span><span class="p">,</span> <span class="nx">json</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span> <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>persist the current user in the players-scored-by-join-time sorted set.
Use their existing score, if any, to avoid bumping them to the end of the
list once they've joined in.</li>
</ol></div></div><div class="code"><div class="wrapper">        <span class="kd">function</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span>   <span class="p">{</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">zscore</span><span class="p">(</span><span class="nx">USER_LIST_KEY</span><span class="p">,</span> <span class="nx">json</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span> <span class="p">},</span>
        <span class="kd">function</span><span class="p">(</span><span class="nx">score</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">zadd</span><span class="p">(</span><span class="nx">USER_LIST_KEY</span><span class="p">,</span> <span class="p">(</span><span class="nx">origScore</span> <span class="o">=</span> <span class="nx">score</span><span class="p">)</span> <span class="o">||</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">(),</span> <span class="nx">json</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span> <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Check the amount of players to maintain our <code>playerCount</code> textual state.</li>
</ol></div></div><div class="code"><div class="wrapper">        <span class="kd">function</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span>   <span class="p">{</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">zcard</span><span class="p">(</span><span class="nx">USER_LIST_KEY</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span> <span class="p">},</span>
        <span class="kd">function</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">self</span><span class="p">.</span><span class="nx">playerCount</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="s1">&#39;Aucun joueur&#39;</span> <span class="o">:</span> <span class="p">(</span><span class="mi">1</span> <span class="o">===</span> <span class="nx">count</span> <span class="o">?</span> <span class="s1">&#39;Un joueur&#39;</span> <span class="o">:</span> <span class="nx">count</span> <span class="o">+</span> <span class="s1">&#39; joueurs&#39;</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">currentQuiz</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">isRunning</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">origScore</span><span class="p">)</span>
            <span class="nx">self</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;quiz-join&#39;</span><span class="p">,</span> <span class="nx">user</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">playerCount</span><span class="p">);</span>
          <span class="nx">cb</span><span class="p">();</span>
        <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is a middleware: don't forget to pass on control to the
remainder of the stack once we're done.</p></div></div><div class="code"><div class="wrapper">        <span class="nx">next</span>
      <span class="p">]);</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tiny callback when our user wasn't found in the session and we looked
them up in the Redis store.</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">handleRedisUser</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">json</span><span class="p">)</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">redirect</span><span class="p">(</span><span class="mi">302</span><span class="p">,</span> <span class="s1">&#39;/front/auth&#39;</span><span class="p">);</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="nx">req</span><span class="p">.</span><span class="nx">user</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span>
        <span class="nx">handleUser</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="scoreboard-computation-on-quiz-end">Scoreboard computation on quiz end</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This computes the final scoreboard for the quiz once it's done,
and persists it into Redis so we can call it up whenever we want.
This sorts players by descending total score.  Ex-aequos are still
ranked separately (just being lazy here) in no particular order
amongst them.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">computeScoreboard</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">computeScoreboard</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">players</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>async.waterfall</code> again, as we have a number of async steps
feeding into each other.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">async</span><span class="p">.</span><span class="nx">waterfall</span><span class="p">([</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Get the entire current-quiz players list.</li>
</ol></div></div><div class="code"><div class="wrapper">      <span class="kd">function</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">hgetall</span><span class="p">(</span><span class="nx">PLAYERS_KEY</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span> <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Turn the resulting list into an ID+score tuple list
sorted by descending score.</li>
</ol></div></div><div class="code"><div class="wrapper">      <span class="kd">function</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">players</span> <span class="o">=</span> <span class="nx">sortPlayerList</span><span class="p">(</span><span class="nx">list</span><span class="p">);</span>
        <span class="nx">cb</span><span class="p">();</span>
      <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Grab the full user/player list and extend the sorted
user-ID list with full properties from it (name, avatar URL).
Also, persist the resulting scoreboard in Redis.</li>
</ol></div></div><div class="code"><div class="wrapper">      <span class="k">this</span><span class="p">.</span><span class="nx">getUsers</span><span class="p">,</span>
      <span class="kd">function</span><span class="p">(</span><span class="nx">users</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">players</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">matchingUser</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">findWhere</span><span class="p">(</span><span class="nx">users</span><span class="p">,</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span> <span class="p">});</span>
          <span class="nx">players</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">matchingUser</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="nx">redis</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">SCOREBOARD_KEY</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">players</span><span class="p">),</span> <span class="nx">cb</span><span class="p">);</span>
      <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Time to call the callback that was passed to us.  We
obey the Node convention of error first, data later, which
lets any other Node-assuming system, including <code>async</code>,
manipulate this very method with confidence.</li>
</ol></div></div><div class="code"><div class="wrapper">      <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">cb</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">players</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">]);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="stats-computation-on-question-end">Stats computation on question end</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When a question is done, we compute basic stats about it: what
the correct answers were, what percentages of answering players
selected each answer, what the overall correct answers ratio was,
and who the current leading players are.  All percentages are
rounded to the nearest integer.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">computeStats</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">computeStats</span><span class="p">(</span><span class="nx">pairs</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Gotta love Underscore. <code>_.pluck</code> grabs the same property out of
every iterable.  This is an optimized special case of <code>map</code>, just
like <code>_.invoke</code> would be for method calls.</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">correctStatuses</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">pluck</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">.</span><span class="nx">answers</span><span class="p">,</span> <span class="s1">&#39;correct&#39;</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For every answer, determine how many players selected it.  Players
can select multiple answers.  This is based on the final state of
play once the question has timed out, as players can adjust their
answers until then.</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">answerSpreads</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">pairs</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">record</span><span class="p">.</span><span class="nx">answerIds</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">id</span> <span class="o">=</span> <span class="o">+</span><span class="nx">id</span><span class="p">;</span>
        <span class="nx">answerSpreads</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">answerSpreads</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">});</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Turn that list of raw counters into count+percentage pairs.  If no
player participated we'll get a weird rounding due to 0/0, so let's
workaround this by setting a floor of 1.</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">playerCount</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">_</span><span class="p">.</span><span class="nx">size</span><span class="p">(</span><span class="nx">pairs</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nx">answerSpreads</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">.</span><span class="nx">answers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">answerSpreads</span><span class="p">[</span><span class="nx">a</span><span class="p">.</span><span class="nx">id</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">count</span><span class="o">:</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">percent</span><span class="o">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">count</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nx">playerCount</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">});</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Determine overall counts (and %) of fully-correct players</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">correctCount</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">where</span><span class="p">(</span><span class="nx">pairs</span><span class="p">,</span> <span class="p">{</span> <span class="nx">currentQuestionCorrect</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}).</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">correctPercent</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">correctCount</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nx">playerCount</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the top 5 scores, and pick 10 random players inside that score range to
report as the currently-leading players.</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">sortedPlayers</span> <span class="o">=</span> <span class="nx">sortPlayerList</span><span class="p">(</span><span class="nx">pairs</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">minimumScore</span> <span class="o">=</span> <span class="nx">sortedPlayers</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">sortedPlayers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">score</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">top5Candidates</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">sortedPlayers</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="nx">minimumScore</span><span class="p">;</span> <span class="p">});</span>
    <span class="kd">var</span> <span class="nx">random10BestIds</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">top5Candidates</span><span class="p">).</span><span class="nx">sample</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nx">pluck</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">).</span><span class="nx">value</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">random10Bests</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Again, <code>async.waterfall</code> lets us "chain" asynchronous operations without falling
into the Pyramid of Doom trap.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">async</span><span class="p">.</span><span class="nx">waterfall</span><span class="p">([</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>We have 10 user IDs: grab all users and map IDs to actual users.</li>
</ol></div></div><div class="code"><div class="wrapper">      <span class="k">this</span><span class="p">.</span><span class="nx">getUsers</span><span class="p">,</span>
      <span class="kd">function</span><span class="p">(</span><span class="nx">users</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">random10Bests</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">users</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">_</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">random10BestIds</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="p">});</span>
        <span class="nx">cb</span><span class="p">();</span>
      <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Compute a textual representation and log it using our theme's debug color
(see below)</li>
</ol></div></div><div class="code"><div class="wrapper">      <span class="kd">function</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39;Answers: &#39;</span><span class="p">;</span>
        <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">answerSpreads</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">spread</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Question indices are turned into letters (A, B, etc.).  Correct answers
are suffixed with a star.</p></div></div><div class="code"><div class="wrapper">          <span class="nx">str</span> <span class="o">+=</span> <span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">65</span><span class="p">);</span>
          <span class="nx">str</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">correctStatuses</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">?</span> <span class="s1">&#39;*&#39;</span> <span class="o">:</span> <span class="s1">&#39; &#39;</span><span class="p">);</span>
          <span class="nx">str</span> <span class="o">+=</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">spread</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="s1">&#39; (&#39;</span> <span class="o">+</span> <span class="nx">spread</span><span class="p">.</span><span class="nx">percent</span> <span class="o">+</span> <span class="s1">&#39;%)&#39;</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">answerSpreads</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nx">str</span> <span class="o">+=</span> <span class="s1">&#39; / &#39;</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="nx">str</span><span class="p">);</span>
        <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="nx">correctCount</span> <span class="o">+</span> <span class="s1">&#39; correct answers total (&#39;</span> <span class="o">+</span> <span class="nx">correctPercent</span> <span class="o">+</span> <span class="s1">&#39;%)&#39;</span><span class="p">);</span>
        <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="s1">&#39;Random 10 Best: &#39;</span> <span class="o">+</span> <span class="nx">_</span><span class="p">.</span><span class="nx">pluck</span><span class="p">(</span><span class="nx">random10Bests</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">));</span>
        <span class="nx">cb</span><span class="p">();</span>
      <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Finally, invoke our passed callback with all proper stats.  We obey Node's
callback style (error, data…).</li>
</ol></div></div><div class="code"><div class="wrapper">      <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">cb</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">correctCount</span><span class="o">:</span> <span class="nx">correctCount</span><span class="p">,</span>
          <span class="nx">correctPercent</span><span class="o">:</span> <span class="nx">correctPercent</span><span class="p">,</span>
          <span class="nx">spreads</span><span class="o">:</span> <span class="nx">answerSpreads</span><span class="p">,</span>
          <span class="nx">statuses</span><span class="o">:</span> <span class="nx">correctStatuses</span><span class="p">,</span>
          <span class="nx">random10Bests</span><span class="o">:</span> <span class="nx">random10Bests</span>
        <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">]);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Just an accessor to gain access to the latest scoreboard, thanks to Redis storage.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">getLatestScoreboard</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">getLatestScoreboard</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">redis</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">SCOREBOARD_KEY</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
      <span class="nx">cb</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">));</span>
    <span class="p">});</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A simple accessor to get the full list of players, least-recent first.  Note that
we let Redis maintain that sort order for us as we store in a sorted set with scores
based on join time.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">getUsers</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">getUsers</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">redis</span><span class="p">.</span><span class="nx">zrangebyscore</span><span class="p">(</span><span class="nx">USER_LIST_KEY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="kc">Infinity</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">users</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">cb</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">users</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">));</span>
    <span class="p">});</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Entry point for answers by players.  The passed <code>answer</code> is expected to be of
the shape <code>{ userId: Number, answerIds: [Number…] }</code>.  This creates/updates
this player's answer to the current question, persisting it in Redis so it survives
server restarts.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">handleAnswer</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">handleAnswer</span><span class="p">(</span><span class="nx">answer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">isRunning</span><span class="p">())</span>
      <span class="k">return</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make sure we have actual Numbers in there, not just Strings.
<code>Number(x)</code> is the nominal conversion protocol, so we can pass <code>Number</code> as a mapper
function.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">answer</span><span class="p">.</span><span class="nx">answerIds</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">answer</span><span class="p">.</span><span class="nx">answerIds</span><span class="p">,</span> <span class="nb">Number</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">redis</span><span class="p">.</span><span class="nx">hget</span><span class="p">(</span><span class="nx">PLAYERS_KEY</span><span class="p">,</span> <span class="nx">answer</span><span class="p">.</span><span class="nx">userId</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">record</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Redis stores values as strings: parse the JSON out of it, if present
(further down, we'll JSONify back before re-storing).</p></div></div><div class="code"><div class="wrapper">      <span class="nx">record</span> <span class="o">=</span> <span class="nx">record</span> <span class="o">?</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">score</span><span class="o">:</span> <span class="mi">0</span> <span class="p">};</span>
      <span class="kd">var</span> <span class="nx">firstTimeAnswer</span> <span class="o">=</span> <span class="nx">record</span><span class="p">.</span><span class="nx">currentQuestionId</span> <span class="o">!==</span> <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
      <span class="nx">record</span><span class="p">.</span><span class="nx">currentQuestionId</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
      <span class="nx">record</span><span class="p">.</span><span class="nx">answerIds</span> <span class="o">=</span> <span class="nx">answer</span><span class="p">.</span><span class="nx">answerIds</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the "current answer set is correct" flag on the fly.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">record</span><span class="p">.</span><span class="nx">currentQuestionCorrect</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">.</span><span class="nx">checkAnswers</span><span class="p">(</span><span class="nx">answer</span><span class="p">.</span><span class="nx">answerIds</span><span class="p">);</span>
      <span class="nx">redis</span><span class="p">.</span><span class="nx">hset</span><span class="p">(</span><span class="nx">PLAYERS_KEY</span><span class="p">,</span> <span class="nx">answer</span><span class="p">.</span><span class="nx">userId</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">record</span><span class="p">));</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Notify the system that an answer was given/updated, and pass individual answer flags
along in case listeners react differently based on selected answer items.  Also pass
the answerer's ID, just in case.</p></div></div><div class="code"><div class="wrapper">      <span class="kd">var</span> <span class="nx">bools</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">.</span><span class="nx">answers</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">_</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">answer</span><span class="p">.</span><span class="nx">answerIds</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="p">});</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">firstTimeAnswer</span> <span class="o">?</span> <span class="s1">&#39;new-answer&#39;</span> <span class="o">:</span> <span class="s1">&#39;edit-answer&#39;</span><span class="p">,</span> <span class="o">+</span><span class="nx">answer</span><span class="p">.</span><span class="nx">userId</span><span class="p">,</span> <span class="nx">bools</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="quiz-activationinitialization">Quiz activation/initialization</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="nx">initQuiz</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">initQuiz</span><span class="p">(</span><span class="nx">quizId</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">reset</span><span class="p">(</span><span class="s1">&#39;quiz&#39;</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In case we got passed a descriptor object, just get its <code>id</code>.</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span><span class="nx">quizId</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
      <span class="nx">quizId</span> <span class="o">=</span> <span class="nx">quizId</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returning a <code>find</code> result, even through <code>success</code>, means we return
a promise for calling code to chain against / wait for, making it
easier to write.</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">Quiz</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">quizId</span><span class="p">).</span><span class="nx">success</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">quiz</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuiz</span> <span class="o">=</span> <span class="nx">quiz</span><span class="p">;</span>
      <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="s1">&#39;Quiz inits: &#39;</span> <span class="o">+</span> <span class="nx">quiz</span><span class="p">.</span><span class="nx">title</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Initializing a quiz resets quiz-state storage, so all players start anew.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">redis</span><span class="p">.</span><span class="nx">del</span><span class="p">(</span><span class="nx">PLAYERS_KEY</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>

        <span class="nx">self</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;quiz-init&#39;</span><span class="p">,</span> <span class="nx">quiz</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Simple helper to tell whether a quiz is currently going on (not just init'd, but started).</p></div></div><div class="code"><div class="wrapper">  <span class="nx">isRunning</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">isRunning</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="k">this</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">;</span> <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="quiz-stepping">Quiz stepping</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is the core step-ahead mechanism for a quiz.  When a quiz starts, it
actually ends up delegating to this.  This returns a promise that calling code
can chain against / wait for to be sure that either the next question is up, or
the quiz is done, except if the quiz isn't even started (returns <code>undefined</code>).</p></div></div><div class="code"><div class="wrapper">  <span class="nx">nextQuestion</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">nextQuestion</span><span class="p">()</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Not started?  Forget it!</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">startedAt</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Next-question selector logic.  We build up selecting options for the ORM.</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">opts</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">where</span><span class="o">:</span> <span class="p">{</span> <span class="nx">visible</span><span class="o">:</span> <span class="kc">true</span> <span class="p">},</span> <span class="nx">order</span><span class="o">:</span> <span class="s1">&#39;questions.position, answers.position&#39;</span><span class="p">,</span>
      <span class="nx">limit</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">include</span><span class="o">:</span> <span class="p">[</span><span class="nx">Answer</span><span class="p">]</span> <span class="p">};</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we run on a randomized quiz, starting it picked a random, one-time ordering
of the questions and stored it in <code>this.questionIds</code>, in which case we should
rely on it. If it's empty, the quiz is done.  Otherwise we'll grab the next
question ID and explictly fetch that one.  If there is no <code>questionIds</code> property,
we'll just get the next question by ascending <code>position</code> order, if any.</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">questionIds</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">questionIds</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">wrapUp</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="nx">opts</span><span class="p">.</span><span class="nx">where</span><span class="p">[</span><span class="s1">&#39;questions.id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">questionIds</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">opts</span><span class="p">.</span><span class="nx">where</span><span class="p">[</span><span class="s1">&#39;questions.position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">gt</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">.</span><span class="nx">position</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Here's our promise result, with a built-in success handler chained in.</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentQuiz</span><span class="p">.</span><span class="nx">getQuestions</span><span class="p">(</span><span class="nx">opts</span><span class="p">).</span><span class="nx">success</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">qs</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">question</span> <span class="o">=</span> <span class="nx">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">question</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There IS a next question matching our criteria?  Awesome, adjust state, persist
in Redis and get on with it!</p></div></div><div class="code"><div class="wrapper">        <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestion</span> <span class="o">=</span> <span class="nx">question</span><span class="p">;</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestionExpiresAt</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">+</span> <span class="nx">question</span><span class="p">.</span><span class="nx">duration</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">.</span><span class="nx">expiresAt</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestionExpiresAt</span><span class="p">;</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestionTimer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">questionExpires</span><span class="p">,</span> <span class="nx">question</span><span class="p">.</span><span class="nx">duration</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestionInterval</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">questionProgresses</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="nx">redis</span><span class="p">.</span><span class="nx">hmset</span><span class="p">(</span><span class="nx">CUR_QUESTION_KEY</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">id</span><span class="o">:</span> <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestion</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
          <span class="nx">remaining</span><span class="o">:</span> <span class="nx">question</span><span class="p">.</span><span class="nx">duration</span> <span class="o">*</span> <span class="mi">1000</span>
        <span class="p">});</span>
        <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="s1">&#39;Question starts: &#39;</span> <span class="o">+</span> <span class="nx">question</span><span class="p">.</span><span class="nx">title</span> <span class="o">+</span> <span class="s1">&#39; (&#39;</span> <span class="o">+</span> <span class="nx">question</span><span class="p">.</span><span class="nx">duration</span> <span class="o">+</span> <span class="s1">&#39;s)&#39;</span><span class="p">);</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;question-start&#39;</span><span class="p">,</span> <span class="nx">question</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuestionExpiresAt</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There ISN'T any question left for our criteria: the quiz is done, wrap it up.</p></div></div><div class="code"><div class="wrapper">        <span class="nx">self</span><span class="p">.</span><span class="nx">wrapUp</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}).</span><span class="nx">error</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;SQL ERROR:&#39;</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Expiry handler bound to a timeout in <code>nextQuestion</code>’s success case.
This clears current timers/intervals, adjusts state, computes and persists
current player scores and question stats.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">questionExpires</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">questionExpires</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">clearInterval</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">currentQuestionInterval</span><span class="p">);</span>
    <span class="nx">clearTimeout</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">currentQuestionTimer</span><span class="p">);</span>
    <span class="nx">redis</span><span class="p">.</span><span class="nx">del</span><span class="p">(</span><span class="nx">CUR_QUESTION_KEY</span><span class="p">);</span>

    <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">async</span><span class="p">.</span><span class="nx">waterfall</span><span class="p">([</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">updatePlayerScores</span><span class="p">,</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">computeStats</span><span class="p">,</span>
      <span class="kd">function</span><span class="p">(</span><span class="nx">stats</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="s1">&#39;Question ends!&#39;</span><span class="p">);</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;question-end&#39;</span><span class="p">,</span> <span class="nx">stats</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">currentQuiz</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">]);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A simple every-second handler that just persists time passing in Redis
for potential fault tolerance and logs question progress.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">questionProgresses</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">questionProgresses</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">remaining</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentQuestionExpiresAt</span> <span class="o">-</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
    <span class="nx">redis</span><span class="p">.</span><span class="nx">hset</span><span class="p">(</span><span class="nx">CUR_QUESTION_KEY</span><span class="p">,</span> <span class="s1">&#39;remaining&#39;</span><span class="p">,</span> <span class="nx">remaining</span><span class="p">);</span>
    <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="s1">&#39;Question has only &#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">remaining</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;s remaining&#39;</span><span class="p">);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A convenience state resetter for quiz and question starts.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">reset</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">reset</span><span class="p">(</span><span class="nx">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;quiz&#39;</span> <span class="o">===</span> <span class="nx">mode</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">currentQuiz</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">startedAt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">redis</span><span class="p">.</span><span class="nx">del</span><span class="p">(</span><span class="nx">PLAYERS_KEY</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">clearTimeout</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">currentQuestionTimer</span><span class="p">);</span>
    <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">questionIds</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">currentQuestion</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentQuestionTimer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">currentQuestionExpiresAt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="quiz-start">Quiz start</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Once a quiz, post-init, has garnered enough players, we can officially start it.
For randomized quizzes, this defines a one-shot, random ordering of questions.
Then this delegates to <code>nextQuestion</code> to pop the first question and get going.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">start</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">start</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">startedAt</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">reset</span><span class="p">(</span><span class="s1">&#39;question&#39;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;random&#39;</span> <span class="o">!==</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentQuiz</span><span class="p">.</span><span class="nx">runningMode</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="s1">&#39;Quiz starts (sequential)&#39;</span><span class="p">);</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">nextQuestion</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Notice the two chained <code>.then</code> calls, that let us sequence asynchronous
functions the way we need them.  For Sequelize calls, <code>.then</code> calls are triggered
on success cases.</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentQuiz</span><span class="p">.</span><span class="nx">getQuestions</span><span class="p">({</span> <span class="nx">where</span><span class="o">:</span> <span class="p">{</span> <span class="nx">visible</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}</span> <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">qs</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Gotta love Underscore…</p></div></div><div class="code"><div class="wrapper">      <span class="nx">self</span><span class="p">.</span><span class="nx">questionIds</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">qs</span><span class="p">).</span><span class="nx">pluck</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">).</span><span class="nx">shuffle</span><span class="p">().</span><span class="nx">value</span><span class="p">();</span>
      <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="s1">&#39;Quiz starts (randomized to &#39;</span> <span class="o">+</span> <span class="nx">self</span><span class="p">.</span><span class="nx">questionIds</span><span class="p">.</span><span class="nx">join</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">);</span>
    <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">nextQuestion</span><span class="p">);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A convenience method called when a question ends, to increment the scores of every
player that was eventually correct, and persist the updated scores in Redis.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">updatePlayerScores</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">updatePlayerScores</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">redis</span><span class="p">.</span><span class="nx">hgetall</span><span class="p">(</span><span class="nx">PLAYERS_KEY</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">pairs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>

      <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">pairs</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">rec</span><span class="p">,</span> <span class="nx">userId</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">pairs</span><span class="p">[</span><span class="nx">userId</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rec</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">rec</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">rec</span><span class="p">.</span><span class="nx">currentQuestionCorrect</span><span class="p">)</span> <span class="p">{</span>
          <span class="o">++</span><span class="nx">rec</span><span class="p">.</span><span class="nx">score</span><span class="p">;</span>
          <span class="nx">redis</span><span class="p">.</span><span class="nx">hset</span><span class="p">(</span><span class="nx">PLAYERS_KEY</span><span class="p">,</span> <span class="nx">userId</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">rec</span><span class="p">));</span>
        <span class="p">}</span>
      <span class="p">});</span>
      <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="s1">&#39;Player scores updated&#39;</span><span class="p">);</span>
      <span class="nx">cb</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">pairs</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="quiz-end">Quiz end</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is called from <code>nextQuestion</code> when it detects the quiz is out of questions.
this computes the final scoreboard, persist it for later reads, resets state and
notifies the system.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">wrapUp</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">wrapUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is the one time we explictly create a Promise.  Because Sequelize already uses
<a href="https://github.com/kriszyp/node-promise">node-promise</a>, we stay with this, but this
code would have been a bit simpler with the <a href="https://github.com/kriskowal/q"><code>q</code></a>
library, where wrapping a regular async method in a promise would just go like
<code>Q.nfcall(self.computeScoreboard).then(function(scoreboard) { … })</code> with no need
to call <code>resolve</code> eventually.</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">computeScoreboard</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">scoreboard</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">reset</span><span class="p">(</span><span class="s1">&#39;quiz&#39;</span><span class="p">);</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;quiz-end&#39;</span><span class="p">,</span> <span class="nx">scoreboard</span><span class="p">);</span>
        <span class="nx">resolve</span><span class="p">();</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">});</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We log in color using not actual color names but semantic names defined in our theme:
this is where we map to supported color codes.</p></div></div><div class="code"><div class="wrapper"><span class="nx">colors</span><span class="p">.</span><span class="nx">setTheme</span><span class="p">({</span>
  <span class="nx">debug</span><span class="o">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span>
  <span class="nx">error</span><span class="o">:</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span>
  <span class="nx">info</span><span class="o">:</span>  <span class="s1">&#39;green&#39;</span><span class="p">,</span>
  <span class="nx">warn</span><span class="o">:</span>  <span class="s1">&#39;yellow&#39;</span>
<span class="p">});</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A convenience timestamped logger method used throughout the engine code.</p></div></div><div class="code"><div class="wrapper"><span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">level</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">message</span> <span class="o">=</span> <span class="s1">&#39;*** [&#39;</span> <span class="o">+</span> <span class="nx">moment</span><span class="p">().</span><span class="nx">format</span><span class="p">(</span><span class="s1">&#39;HH:mm:ss&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;] &#39;</span> <span class="o">+</span> <span class="nx">message</span><span class="p">;</span>
  <span class="p">(</span><span class="nx">console</span><span class="p">[</span><span class="nx">level</span><span class="p">]</span> <span class="o">||</span><span class="err"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)(</span><span class="nx">message</span><span class="p">[</span><span class="nx">level</span><span class="p">]);</span>
<span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A convenience method taking a Redis-issued hash of <code>{ userId: stateInfo }</code> tuples
and turning it into a descending-score <code>Array</code> of <code>{ id: Number, score: Number }</code> tuples.</p></div></div><div class="code"><div class="wrapper"><span class="kd">function</span> <span class="nx">sortPlayerList</span><span class="p">(</span><span class="nx">pairs</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is a massive example of Underscore's power.  We let it operate in sequence on <code>pairs</code>,
JSON-decoding values on the fly, map to proper tuples, and sort by a computed property.
The equivalent JS code would take a fair number of lines…</p></div></div><div class="code"><div class="wrapper">  <span class="k">return</span> <span class="nx">_</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">pairs</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">rec</span><span class="p">,</span> <span class="nx">userId</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">_</span><span class="p">.</span><span class="nx">isString</span><span class="p">(</span><span class="nx">rec</span><span class="p">))</span>
        <span class="nx">rec</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">rec</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">,</span> <span class="nx">score</span><span class="o">:</span> <span class="nx">rec</span><span class="p">.</span><span class="nx">score</span> <span class="p">};</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nx">sortBy</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="nx">r</span><span class="p">.</span><span class="nx">score</span><span class="p">;</span> <span class="p">})</span>
    <span class="p">.</span><span class="nx">value</span><span class="p">();</span>
<span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The engine code often passes methods of the <code>Engine</code> singleton as references
(as callbacks, or sequence items in <code>async.waterfall</code>, or other situations).  In
such situations, JS would <strong>lose scope</strong> (lose the expected meaning of <code>this</code> to make
it reference the global object).  So we ask Underscore to overwrite the necessary methods
with a pre-bound version of them, one that is inherently attached to the <code>Engine</code> instance.</p></div></div><div class="code"><div class="wrapper"><span class="nx">_</span><span class="p">.</span><span class="nx">bindAll</span><span class="p">(</span><span class="nx">Engine</span><span class="p">,</span> <span class="s1">&#39;computeStats&#39;</span><span class="p">,</span> <span class="s1">&#39;getUsers&#39;</span><span class="p">,</span> <span class="s1">&#39;handleAnswer&#39;</span><span class="p">,</span> <span class="s1">&#39;nextQuestion&#39;</span><span class="p">,</span>
  <span class="s1">&#39;questionExpires&#39;</span><span class="p">,</span> <span class="s1">&#39;questionProgresses&#39;</span><span class="p">,</span> <span class="s1">&#39;updatePlayerScores&#39;</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">Engine</span><span class="p">;</span></div></div></div></div></body></html>